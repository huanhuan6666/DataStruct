# 图(graph)

## 基本概念
就是点集V和边集E，用一个**点的二元组**表示边。
对于**无向图**，边用**圆括号**表示`(v1, v2)`；对于**有向图**，边用**尖括号**表示`<v1, v2>`。
> 可以看到，**“点”**才是图的核心，而**“边”**体现的是点之间的**关系**，是依附于点产生的概念，**没有点边就没有意义**。
> 
> 况且“边”就是用它的**两个顶点表示的**。

本章我们不对图这个概念深究，只考虑最简单的有向图和无向图，**不考虑自环**(即边的两点是同一个点)，也**不考虑无向图的多重边**(即两点之间有多条无向边)

* 完全图：无向图的完全图就是有`n(n-1)/2`条边的图，有向图是有`n(n-1)`条边的图（无向图的2倍，每条无向边变成两条有向边）
* 边的权值：可以表示边的距离，代价等等
* 点的度：点关联的**边的条数**，有向图还有**入度和出度**，为入度和出度**之和**
* 路径：我们的定义是路径是一系列**点**的**序列**。如果所有点都不重复则为**简单路径**，如果第一个点和最后一个点相同，则为**回路**，其余为**复杂路径**
* 连通图：无向图中，若**任意两点间**都有路径则称之为连通图；非连通图的**极大连通子图**叫做**连通分量**
> 一个**无向连通图**的**生成树**是它的**极小连通子图**，如果有n个点则有**n-1条边**，这是最小的连通保证
* 强连通图：有向图中，任意两点间可以**相互到达**，称其为强连通图；非强连通图的**极大强连通子图**叫做**强连通分量**
> 可以看到连通图是**无向图**的概念，强连通图是**有向图**的概念，浅浅区分一下😋


## 图的存储表示
注意这部分的实现，**不保证可以顺利编译通过**。

* 关于模板

受限图的ADT也就是那个`Graph`用的是模板抽象类，而邻接矩阵和邻接表实现是**继承自模板类**Graph的**模板类**。

C++关于模板的实现很乱我只能说😅**两次编译**啥的，一个很直观的例子就是：如果是模板类继承模板类，那么**父模板类**里的`public`或者`protected`变量在**子模版类**里**无法直接访问**。

这tm的简直荒谬😅原因和模板类二次编译有关，由于编译时未生成实际的模板代码，名字查找都是现场决议的，编写时只能在子类里通过:
```cpp
this->numEdges += 1; //this指针
Graph<T, W>::numEdges += 1; //基类名受限
```
两种方式来访问原本在普通子类里可以直接访问的东西。有云CS106L原话如下：
> Templates don’t emit code until instantiated, so #include the .cpp file in the .h file, not the other way around!

我只能说C++的水太深了😭

* 关于实现细节

实现上我是为了和课本课件一致使用了 `<class T, class W>`这种模板，但是诸如表示邻接矩阵两个点之间没有边时，理论上应该提供一个**类型为`W`的无穷大**。

但是我为了省事直接用`INT32_MAX`表示了
> 因此大概率编译不通过，反正也没打算跑通😋

### 邻接矩阵表示法

在 `GraphMatrix`类中实现的是**无向图**，也就是说二维矩阵`edgeMatrix`是**对称的**。
* 若 `i == j` 则 `edgeMatrix[i][j] = 0`
* 若  `edgeMatrix[i][j] = INT32_MAX`，表示点i和点j之间**没有边**
> INT32_MAX是偷懒的做法，前面已经说过了，应该实现一个T类型的表示无穷的实例才对🤭

**函数相关：**

需要注意，点的类型是`T`，实际点的值存放在 `vector<T> vertexList`中。

各种成员函数中参数和返回值的 `int v1, int v2`实际上是**该结点在`vertexList`中的下标位置**

### 邻接链表表示法

典中典的，二维矩阵很可能出现**稀疏矩阵**的情况，边很少，导致**内存的浪费**。

于是就有邻接链表表示法，但是需要清楚，这只是对于**内存的一种优化**，二维矩阵虽然空间复杂度大，但是数组**支持下标随机查询**非常快，属于**空间换时间**。

其实就是把邻接矩阵的**每一行组织成一个链表**。链表中的结点有**顶点的下标**和该**边的权值**，顶点表存有**该点的值**以及**出边链表**。

> 实现草草写下一下早点完事吧😭后面的各种算法才是重点

而且，有了STL谁tm还写链表啊😅顶点表是个 `vector<pair<T, vector<Edge>>>`，顶点表中存的是一个pair，T就是顶点的值，而`vector<Edge>`就是**出边链表**。

每个`Edge`有终点的**下标值**和**这条边的权值**两个域。

### 邻接多重表
课上没讲，那就不看了🙈浅浅看了一下发现好麻烦就是说

## 图的遍历
* 概念

从给定连通图的**某一个顶点**出发，沿着一些边访问图中的**所有顶点**，使每个顶点被访问且**仅被访问一次**，这就是图的**遍历**。

* 与树遍历的区分

我们知道树其实是一种特殊的图，即**边最少的连通图**，且边是**有向的**：即**从父结点指向子结点**。

因此原来树的遍历中我们根本不用考虑**每个结点只被访问一次**，因为边的方向导致树绝对不会像图那样**可能出现回路**，导致沿着边走很可能对点**重复访问**。

* 辅助数组

因此，为了**避免重复访问**，在图的遍历中，**不得不引入辅助数组**`bool visited[]`来标记某个点是否被访问过了。

### DFS深度优先搜索
典中典的递归了，注意为了不重复搜索，**必须要用**`visited`数组来标志某个顶点是否被访问过。

因为这是**遍历**，每访问一个顶点直接标记成 `visited[v] = true`，**不进行状态回退**
> 否则就成回溯了，这里就是纯纯遍历，不搞什么尝试花里胡哨的😋

代码如下：
```cpp
//从下标v开始递归DFS访问图G
template<class T, class W>
void DFS(Graph<T, W>& G, int v, vector<bool>& visited) {
    cout << G.getValue(v) << " " << endl; //访问这个点
    visited[v] = true;  //标记访问 防止重复访问
    int neighbor = G.getFirstNeighbor(v);   //邻居的下标
    while(neighbor != -1) { //递归DFS访问v的所有邻居
        if(!visited[neighbor]) //防止重复访问
            DFS(G, neighbor, visited);
        neighbor = G.getNextNeighbor(v, neighbor);
    }
}
```

这个函数是递归函数的内部调用本身，它外面还套了层外部调用`DFSearch()`，都是典中典了不废话了。

* **复杂度**：假设图中有n个顶点，e条边

如果用邻接矩阵，则每次找某个点的**邻接边**即`nextNeighbor`的时候需要遍历矩阵中的**第n行**，因此整体的复杂度为`O(n^2)`
> 和e完全没有关系，因为用邻接矩阵的话，找边还得遍历整个矩阵

而使用邻接矩阵的话，同样n个点，但找某个点的**邻接边**只需遍历链表，不多不少正好只需遍历e次，因此整体复杂度为`O(n+e)`
> 因为链表存的就确确实实是边的信息，而不会像矩阵那样有很多没用的空元素


### BFS广度优先搜索

还是用队列，和树一样的，区别同样还是需要用`visited`数组来防止重复遍历，不赘述了。

* **复杂度**：假设图中有n个顶点，e条边

和DFS的分析思路完全一样，问题的关键在于如何**确定某个顶点所有邻居**，邻接表复杂度为`O(n+e)`，比邻接矩阵`O(n^2)`要节约。


### 搜索的应用一：确定连通分量

显然在图中一个顶点开始搜索，只能遍历到**一个连通分量**的所有点。

于是可以尝试从**每个顶点**开始遍历，这样一定可以保证非连通图的**所有连通分量**都被遍历到，同时可以确定每个连通分量**由哪些点**构成。

代码很简单，就是遍历一番：
```cpp
template<class T, class W>
void Components(Graph<T, W>& G) {
    int v_count = G.getNumVertexs();
    vector<bool> visited(v_count, false);
    for(int i = 0; i < v_count; i++) {
        if(!visited[i]) {
            DFS(G, i, visited);
            cout << "-----------------------" << endl;   //每一个连通分量结束后都有分隔线
        }
    }
}
```

### 搜索的应用二：图的生成森林

对于**每一个**连通分量，用DFS或者BFS从一个点开始遍历时，**走过的边**的集合都会形成一棵**生成树**，个生成树就是**该连通分量的极小连通子图**。

因此对于包含几个连通分量的非连通图就可以不断遍历，**每个连通分量得到一棵生成树**，最后得到该**非连通图的生成森林**。

具体达到一个什么样的效果呢？示例如下：对于非连通图a，经过DFS遍历后**每个连通分量**得到一颗生成树，如图b有三棵，但这是多叉形式的。

<img alt="img.png" src="../picture/img_15.png" width="380" height="160"/>

用**子女-兄弟**表示法将这几棵多叉树统一起来得到**二叉表示的森林**如下：

<img alt="img.png" src="../picture/img_16.png" width="280" height="150"/>

这个就叫做：图的**深度优先生成森林**，每个连通分量对应一个**深度优先生成树**。

#### 用子女-兄弟法来构建图的生成树
图的结构很复杂，一个父结点可能对应很多个子结点，显然不能用简单的左右子树二叉树，需要用**子女-兄弟表示法**，具体实现在`Tree/Tree.h`文件里。
> 我包的就是这个头文件🤭 但是好像这个森林的实现原来不太全，后来发现课本课件上就没给全😥`Insert`和`BulitRoot`方法都是自己新写的

显然递归的外部调用需要遍历所有的点，每找到一个新的`visited[i]==false`时说明得到一个**新的连通分量**即一棵**新的子树**，应该变成**根的兄弟**。

也就是在根上**不断添加新的兄弟**，代码如下：

```cpp
for(int i = 0; i < v_count; i++) {
    if(!visited[i]) { //一个新的连通分量 即一棵新的生成树
        visited[i] = true; //其实可以省略 因为这是DFS_Tree的职责
        if(forest.IsEmpty()) { //生成森林里的第一棵树
            subTree = root = forest.BulitRoot(G.getValue(i)); //建立森林的根
        }
        else { //新的生成树 是兄弟
            subTree = forest.InsertRightSibling(subTree, G.getValue(i));
        }
        DFS_Tree(G, forest, subTree, i, visited);
    }
}
```
这里的每个`subTree`代表一个新连通分量即**新子树的根节点**，代表图G的顶点i。


现在问题变成了，如何在**一个连通分量**里创建深度优先搜索树。这就是函数 `DFS_tree()`的工作
> `DFS_tree_new()`是课件的做法，二者思路完全一致，就是说课件的方法更加简洁一些😭

```cpp
void DFS_tree(Graph<T, W>& G, Tree<T>& forest, TreeNode<T>* subTree, int v, vector<bool>& visited)
```
其中`G`是图本身，`forest`是森林本身，`subTree`是想要操作的森林结点的指针，从我们的实现可以看到，**调用时`subTree`代表的结点保证已经new出来了**，`visited`就是访问数组。

`v`是`subTree`指针**所代表的图中的顶点下标**，因此问题就变成了：找顶点v的**所有邻居**，**递归构建**邻居的子树即可。

由于**长子-兄弟**表示法，将**第一个邻居**作为`subTree`结点的`leftChild`结点，**剩下的邻居**都是**长子的兄弟**即`rightSibling`结点。

代码如下：
```cpp
template<class T, class W>
void DFS_tree_new(Graph<T, W>& G, Tree<T>& forest, TreeNode<T>* subTree, int v, vector<bool>& visited) {
    visited[v] = true;
    int neighbor = G.getFirstNeighbor(v);
    bool IsFirstSon = true;   //判断该邻居是否为长子 作为subTree的leftson
    TreeNode<T>* firstSon = nullptr;
    while(neighbor != -1) {
        if(!visited[neighbor]) {
            if(IsFirstSon) { //是长子 插入左结点
                firstSon = forest.InsertLeftChild(subTree, G.getValue(neighbor));
                IsFirstSon = false;   //此后的邻居都是长子的兄弟
                DFS_tree_new(G, forest, firstSon, neighbor, visited); //递归建立长子下的森林
            }
            else { //长子的兄弟
                auto sibling = forest.InsertRightSibling(firstSon, G.getValue(neighbor));
                DFS_tree_new(G, forest, sibling, neighbor, visited));  //递归建立结点下的森林
            }
        }
        neighbor = G.getNextNeighbor(v, neighbor);
    }
}
```
对于`visited`数组的修改在函数的开始位置，只需要保证在**递归前修改**了`visited`数组即可，防止无限递归就行。
> 但是显然课本的实现比我那种各个分支写一遍要高明的多，因为`if`判断能进到递归里说明这个点肯定`visited`为`false`
> 
> 是我比不上了就是说，写的时候没考虑清楚这个递归，其实**递归子问题**就是自己的**那些邻居**，只不过由于**长子-兄弟**表示法对**不同的邻居**特判一下😥

### 深度优先生成树的应用：寻找关节点

* 概念

对于一个连通图上的某一点，若删除该点**以及关联的边**，该图**不连通**了，则这个点就是**关节点**，如下图点B E F G都是关节点：

<img alt="img.png" src="../picture/img_17.png" width="465" height="341"/>

* 如何寻找

可以利用**DFS生成树**。对于**根结点**：若其子女数超过一，则它就是关节点；对于**非根节点**：若其子女(有的话)有不经过它就可以到达其祖先的路径，则**不是**
> 其实就是判断删掉这个点其余点能否连通，根节点既然有**多个子树**，那么子树之间的连通**必定不得不经过根**因此他就是关节。
> 
> 而非根节点也就是看看**其子女到其祖先有无多条路径**，如果没有那删去它它的子女**真就无法到达**它的祖先了，因此成了关节，没什么玄的🙃


课本上的例子是子女表示法，但是之前我们表示DFS生成树用的是**长子-兄弟**，**一回事的**。

## 最小生成树

### Kruskal算法

### Prim算法


## 最短路径

## 活动网络
