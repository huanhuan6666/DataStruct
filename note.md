# 数据结构

## 线性表
线性表是一种抽象数据类型，即每个结点只有**唯一的**前驱结点和后继结点。内部的实现可以用顺序存储(基于数组)或者链式存储(基于链表)

我们将线性表封装成一个**抽象基类**，在文件`LinearList.h`中，定义了一堆纯虚函数，即线性表需要提供的接口，之后用顺序存储和链式存储的方式分别实现。

下面的实现中，我们默认的下标位置**从0开始**.

### 顺序存储
定义在`LinearList/SeqList.h`文件中，是抽象基类的一个实现。

抽象基类的构造函数和析构函数完全可以不写，写的话需要加上`=default`的关键字。

* `last == -1;`表示线性表为空

* `size == last + 1;`这是invariant，即该类在任何情况下都要满足的**定式**

### 链式存储
定义在`LinearList/LinkList.h`文件中，也是抽象基类的实现，不过由于抽象基类把诸如Search和Locate这样的函数，返回值都固定成int，这是否有点管的太宽。

索性不虚函数了，就是说这书上真是错误百出，顾头不顾尾😅


一个简单的测试函数：
```cpp
int main() {
    List<int> myseq;
    myseq.Input();
    cout << myseq.Locate(3)->data << endl;
    myseq.Output();
    return 0;
}
```
### 循环链表
定义在`LinearList/CircList.h`文件中，同样设置了结点**结构体**和链表类，操作大同小异，只不过对于last结点的处理可能会复杂一点，因为不再指向NULL而是指向first，

因此关键就在于末尾结点处的增删，要保证**成环**就OK。

这个循环链表我们也添加了**附加头节点**。

### 双向循环链表
双向循环链表**同样添加**附加头节点，定义在`LinearList/DblList.h`中，双向链表就好用多了，只要找到需要的那个cur结点，左右就全知道了，根本不用再像单向那样需要凑cur之前的那个结点。

缺陷就是两个左右指针操作起来比较麻烦点。



## 栈
线性表，不管是顺序存储还是链式存储，我们说的是ADT的线性表，是栈和队列的基础。

栈和队列，是**限制存取位置**的表结构。

很容易理解，比如STL的vector明明就能实现栈的功能，但是还有stack这种wrapper套皮vector的栈，就是因为ADT stack的Function是不提供按照下标访问功能的。

### 顺序栈
我们实现的最基础的基于数组的**顺序栈**模板类定义在`Stack/Stack.h`文件中。

我们约定：
  * `top == -1`时栈为空
  * `top`表示栈顶元素的下标

### 双栈共享栈空间
这是个比较秀的结构，说是为了更好地利用内存空间，减少内存的浪费。定义在`Stack/DualStack.h`文件中。

让两个栈共享一个数组，一个从0到maxSize生长，另一个从maxSize到0生长，有点像内存模型的栈和堆**双向奔赴**就是说😄

使用时需要指定用哪个栈，于是约定：
* 栈顶碰到一起则栈满了
* `top == 0`或者`top == maxSzie`为空，取决于用哪个栈，是从高到底生长还是从低到高生长。

不会真有人用这种东西吧，有点古早就是说，也可能是现在的封装库已经足够强大了。

### 链式栈

上面那种双栈共享空间来节省空间实在有点辣眼睛，还是链式存储吧。定义在`Stack/LinkedStack.h`文件中。

* 没有附加头节点，也就是说`top == nullptr`栈为空

* `push`和`pop`都直接用最简单的头插法，并且显然，链式栈不可能满。

### 栈的应用
典中典的计算中缀表达式，我们不必把中缀表达式转换成后缀，然后再解析后缀表达式那么麻烦，而是直接用双栈法。

* 设置一个val栈，一个opt栈，每读到一个数字就压如val栈，读到opt的话：
  * 设置opt的优先级，( 最低=0，+-=1， */=2，)最高=3
  * 如果当前的opt的优先级比opt.top()的优先级**高或等于**，那么就pop出opt的top并且val的两个值计算后再次push入val栈中
    * 直到当前的opt的优先级**大于**opt的top，或者栈为空或者遇到(才停止pop，将当前操作符压入opt中
    * 如果当前opt为)那么遇到(的话，也需要将(弹出，也就是说一对括号已经完成它的使命了🤭
    * 这样保证了高优先级的运算符先执行，同等优先级的运算符按从左到右的顺序执行
* 首先在opt栈push进(并在exp后加上`)`作为**哨兵**，保证最后压入)后可以保证将栈opt清理干净

简单计算器的实现在文件`SimpleCalculator.cpp`中，利用的是上面实现的链式栈，只能实现**一位整数**的加减乘除。

没有转换成后缀再去解析，是因为生成后缀表达式的过程和上面几乎完全一致，没有必要多此一举，如果确实需要后缀表达式的话：
* 不需要val栈，因为遇到数字直接输出，只需要opt栈，对于opt的操作和上面完全一致
* 当然可以设置()哨兵，即在opt栈先压一个(，在字符串最后拼一个)
> 因为后缀表达式不会出现括号。设置哨兵可以保证最后的)可以清空opt栈，更方便。

解析后缀表达式时，不用opt栈只用val栈，碰见数字直接压入val栈，碰见符号则弹出两个数字**计算后再压入**val栈，最后val栈的栈顶就是计算结果。

😄就是说生成后缀表达式只用opt栈，解析后缀表达式只用val栈，索性**直接双栈**痛快点。

## 队列
FIFO的结构，这里实现一个顺序存储一个链式存储。

### 顺序存储--循环队列
既然按照顺序存储，如果不提供自动扩展的话，队列能存放的最大元素个数是固定的。

一个循环队列的实现定义在文件`Queue/SeqQueue.h`中：
* `tail == head`时队列为空
* `tail + 1 == head`时队列为满
* `tail`实际上一直指向下一个可以写的空结点，但是为了方便判断队列满，实际上队列最后一个结点是无法使用到的。

### 链式队列
一个链式队列的实现在`Queue/LinkedQueue.h`文件中。

如果链式的话，那就不存在队列满的问题了，由于队列的操作是在头部和尾部进行的，因此需要`tail`和`head`指针。
* 当 `head == nukllptr`时队列为空

### 优先级队列
优先级队列的实现在 `Queue/PQueue.h`文件中。

同样是先进先出的结构，但是这个队列在 `push`的时候要自动按照优先级调整队列中元素的顺序，使得每次 `pop`的时候都是优先级**最高**的元素。

一般数字**越小**，优先级**越高**。

主要就是在普通队列插入后增加了一个 `adjust()`函数调整，将最新插入的元素找到一个合适的位置，一个个比较，复杂度为O(n)，就相当于插入排序了。


### 队列的应用

* 逐行打印二项展开式的系数

实现在`Queue/Pascal.cpp`文件中，首先向队列中压入初始的`011`，之后`pop`一个`getTop`一个，如果`first==0`则压入0和`first+second`，否则只压入`first+second`。

遇到`first == 0`就输出一个换行🤭

实现在 `Queue/Pascal.cpp`文件中。

## 数组、串和广义表
* 一维数组、二维数组多维数组那些东西，C语言的典中典了这里就不多说了，指针和内存模型之类的。。

* 还有对称矩阵的压缩：上三角和下三角矩阵存放到**数组**里，这样可以省一半的空间，然后根据二维元素的下标**计算出**数组中的下标来进行读写操作。
  三对角矩阵的压缩也同样，放到数组里然后计算**下标的映射关系**。

### 稀疏矩阵
这里主要实现一个稀疏矩阵吧，如果矩阵中**非零元素**占比 < 0.05，那这个矩阵就太稀疏了，很多空间都是浪费的，我们考虑用**三元组**表示那些非零结点：
```cpp
template<class T>
struct Triple{
    int row,col; //非0元素的行和列值
    T value;  //元素值
};
```
这里存的 `m_data`即`Triple<T>`结构体数组，信息少的可怜，我们的做法是让行数较小的元素三元组放到`m_data`数组中靠前的位置，即按照原始矩阵的**从上到下从左到右的顺序**存到`m_data`中。

于是有一个原始版的矩阵转置函数，就是扫描`m_col`**遍**所有元素，即`m_col`行，每次扫描找转置后**该行**的元素放到新数组中。
> 纯纯的暴力，复杂度是O(n*t), t是非零元素个数

于是就有：

* 快速转置算法

首先扫描一遍元素，对于转置后的每一行的元素信息存起来，即：每一行元素的个数和起始位置。然后再扫描一遍按照对应行的起始位置填写就行了。关键代码如下：
```cpp
for (int i = 0; i < m_term; i++) { //统计每一行的元素个数
    row_size[m_data[i].col]++;
}

row_start[0] = 0; //设置每一行的起始位置
for (int i = 1; i < m_col; i++) {
    row_start[i] = row_start[i - 1] + row_size[i - 1]; //第i行的起始位置
}

//开始填写
for (int i = 0; i < m_term; i++) {
    int the_row = m_data[i].col; //该元素应该在第the_row行
    int start = row_start[the_row]; //该元素应该放在的位置
    b.m_data[start].row = the_row;
    b.m_data[start].col = m_data[i].row;
    b.m_data[start].data = m_data[i].data;
    row_start[the_row]++; //修改这一行的起始位置
}
```
设置起始位置时，首先第0行的起始位置一定是0，然后第i行的起始位置=第i-1行的起始位置 + 第i-1行的元素个数。


这个方法还是比较好的，完完全全的下标操作，只存下标信息，**空间复杂度**尽可能降到了很小。
> 如果是我的话我可能直接二维vector了🤣当然不可能用堆区动态数组这种方法存结点，但是毕竟讲数据结构还是暂时远离STL吧
> 
> 就是说这个存下标的做法是正确的，一针见血的🤭重点抓的很好

上面的代码在`Table/SparseMatrix.h`文件中。

* 更多的表示方法

起始上面也看到了，用一个三元结构体的动态数组表示稀疏矩阵，处理起来很麻烦，虽然存储结构比较简单，但操作起来就很复杂。

课件上给了两种，一个将行拿出来，即列和数据二元结构体，然后把每一行的指针放到一个数组里，有点像二维动态那样子，但是课件上**仍然用数组**存二元结构体。
> 我不知道为什么不用二维动态数组，这个课件最后总是想用固定大小的数组来存结点，可能是考虑**非零元素个数固定**？不过这里确实二维动态的话有点小题大做，好吧我承认它重点抓的比较好，不做无用功是吧🤭
> 
> 😄就是说STL真伟大。


* 当然也祭出了十字链表这种东西

什么动态二维往后稍稍，知道什么叫动态么。直接给你正交，每个结点有个`down`和 `right`两个指针，每一行每一列还能成循环。

就是说这个东西还得用在矩阵加减运算的时候，因为上面我是没有实现矩阵加减操作的，因为涉及到生成新结点，不得不对数组大小进行调整，非常麻烦。。。

但是正交链表的话是很方便插入的，太麻烦了不想写www😭


### 字符串
#### KMP算法！

### 广义表


## 树和二叉树

## 排序

