# 数据结构

## 线性表
线性表是一种抽象数据类型，即每个结点只有**唯一的**前驱结点和后继结点。内部的实现可以用顺序存储(基于数组)或者链式存储(基于链表)

我们将线性表封装成一个**抽象基类**，在文件`LinearList.h`中，定义了一堆纯虚函数，即线性表需要提供的接口，之后用顺序存储和链式存储的方式分别实现。

下面的实现中，我们默认的下标位置**从0开始**.

### 顺序存储
定义在`LinearList/SeqList.h`文件中，是抽象基类的一个实现。

抽象基类的构造函数和析构函数完全可以不写，写的话需要加上`=default`的关键字。

* `last == -1;`表示线性表为空

* `size == last + 1;`这是invariant，即该类在任何情况下都要满足的**定式**

### 链式存储
定义在`LinearList/LinkList.h`文件中，也是抽象基类的实现，不过由于抽象基类把诸如Search和Locate这样的函数，返回值都固定成int，这是否有点管的太宽。

索性不虚函数了，就是说这书上真是错误百出，顾头不顾尾😅


一个简单的测试函数：
```cpp
int main() {
    List<int> myseq;
    myseq.Input();
    cout << myseq.Locate(3)->data << endl;
    myseq.Output();
    return 0;
}
```
### 循环链表
定义在`LinearList/CircList.h`文件中，同样设置了结点**结构体**和链表类，操作大同小异，只不过对于last结点的处理可能会复杂一点，因为不再指向NULL而是指向first，

因此关键就在于末尾结点处的增删，要保证**成环**就OK。

这个循环链表我们也添加了**附加头节点**。

### 双向循环链表
双向循环链表**同样添加**附加头节点，定义在`LinearList/DblList.h`中，双向链表就好用多了，只要找到需要的那个cur结点，左右就全知道了，根本不用再像单向那样需要凑cur之前的那个结点。

缺陷就是两个左右指针操作起来比较麻烦点。



## 栈
线性表，不管是顺序存储还是链式存储，我们说的是ADT的线性表，是栈和队列的基础。

栈和队列，是**限制存取位置**的表结构。

很容易理解，比如STL的vector明明就能实现栈的功能，但是还有stack这种wrapper套皮vector的栈，就是因为ADT stack的Function是不提供按照下标访问功能的。

### 顺序栈
我们实现的最基础的基于数组的**顺序栈**模板类定义在`Stack/Stack.h`文件中。

我们约定：
  * `top == -1`时栈为空
  * `top`表示栈顶元素的下标

### 双栈共享栈空间
这是个比较秀的结构，说是为了更好地利用内存空间，减少内存的浪费。定义在`Stack/DualStack.h`文件中。

让两个栈共享一个数组，一个从0到maxSize生长，另一个从maxSize到0生长，有点像内存模型的栈和堆**双向奔赴**就是说😄

使用时需要指定用哪个栈，于是约定：
* 栈顶碰到一起则栈满了
* `top == 0`或者`top == maxSzie`为空，取决于用哪个栈，是从高到底生长还是从低到高生长。

不会真有人用这种东西吧，有点古早就是说，也可能是现在的封装库已经足够强大了。

### 链式栈

上面那种双栈共享空间来节省空间实在有点辣眼睛，还是链式存储吧。定义在`Stack/LinkedStack.h`文件中。

* 没有附加头节点，也就是说`top == nullptr`栈为空

* `push`和`pop`都直接用最简单的头插法，并且显然，链式栈不可能满。


## 队列

## 树和二叉树

## 排序

