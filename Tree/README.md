
## 二叉树
### 基本术语
* 层次：规定根结点在**第一层**，其子女结点的层次等于根结点层次加一，依次类推。
* 深度：结点的深度和层次一样，根的深度为1，**最深结点**表示树的深度。
* 高度：规定**叶结点**高度为1，越往上高度越高，**根节点最高**，根的高度即为树的高度。
* 度：结点的**子女个数**即为该结点的度，即**出边数**，**最大**的结点度为树的度
* 森林：是树的集合
* 有序树：树中某结点的各个子树是有次序的，比如左子树和右子树不同，不能交换，则称其为有序树

### 定义
* 从数学的角度出发，二叉树是**结点的**一个**有限集合**，该集合或者**为空**，或者是由一个**根**和**互不相交**的左右**子二叉树**构成。
> 可以看到严格的概念定义中，空树也是二叉树！因此很多递归的终止条件为 `if(root==nullptr)`是完全合理自洽的
>
> 因此二叉树有5种形态：空、只有根、根和左子树、根和右子树、根和左右子树

* 且树是**边最少的连通图**，有等式 `点数 == 边数 + 1`恒成立，因此若度为0的结点数为`n0`，度为2的结点树为`n2`，有`n0 == n2 + 1`恒成立。
> 设度为1的结点数为 `n1`，则有 `n0 + n1 + n2 = n1 + 2*n2 + 1`，即 `n0 = n2 + 1`

* 满二叉树：所有层的结点都是满的，即深度为i的满二叉树，结点总数为 `2^i-1`个。
* 完全二叉树：设二叉树深度为k，若第1层到第k-1层都是满的，只有第k层**从右到左缺**若干结点(可以不缺)，则称其为完全二叉树。
> 那么深度为k的完全二叉树，结点总数为n，则有: `2^(k-1)-1 < n <= 2^k-1`，变形得 `2^(k-1)< n+1 <=2^k`，取对数，有`ceil(log(n+1)) = k`
>
> 设二叉树有n个结点，从根到下从左到右从1开始给每个结点编号，则有关系如下：

<img alt="picture/img_1.png" height="222" src="../picture/img_1.png" width="408"/>

### 二叉树的表示
* 顺序表示

> 适用场景比较特殊，表示**完全二叉树**是优越的；但没办法高效表示**一般**的二叉树，每一层一有空结点就会造成数组元素的浪费。

就是用数组，每个结点都有编号对应**数组下标**，即使为**空也占位**。

因此在表示**完全二叉树**时，没有数组元素的浪费，因为都是满的最后一层结点也是从左到右排列。

而极端情况下，只有**右单支**的二叉树则浪费最多，第i层浪费 `2^(i-1)-1`个数组元素。

* 链式表示

对于通用的二叉树，链式才是典中典，相应的在链式结构上的**递归算法**也是典中典。

最典型的，**二叉链表**表示，只有左右子树两个指针：
```cpp
template<class T>
struct node{
    T data;
    node *left;
    node *right;
};
```
当然课件上也给了**三叉链表**表示法，多了一个指向父结点的指针
> 加的`parent`指针域有点像Linux中的..目录，也可以区分，在一些场景下，比如查找父结点时还是很方便的
```cpp
template<class T>
struct node{
    T data;
    node *parent;
    node *left;
    node *right;
};
```

当然也祭出了**静态链表**表示法，hh有链表的地方就考虑用静态大小的数组结构表示一下，虽然我从来没用过就是说🤣直接看图吧， `data`就是固定大小为6的数组，存储所有6个树结点：

<img alt="img_2.png" height="200" src="../picture/img_2.png" width="270"/>

### 一些算法

典中典的求深度，求结点个数，求父结点就不用多说了，阉割版的广义表了属于是。说一下根据前序遍历序列创建二叉树吧。

* 二叉树的创建

比如 `ABC@@DE@G@@F@@@;`的序列，由于先序的特点，递归函数也是先序顺序创建的。说说函数原型：
```cpp
CreateBinTree(istream &in, BinTreeNode<T> *&r) {
    T chr;
    in >> chr;
    if(chr == ';')
        return;
    if(chr == '@') { //表示空
        r = nullptr;
        return;
    }
    //不为空则创建 根结点
    r = new BinTreeNode<T>;
    r->data = chr;
    CreateBinTree(in, r->left);
    CreateBinTree(in, r->right);
}
```
注意到参数 `r`是个**指针的引用**，回想之前创建广义表的时候放入的是指针，是因为那里的 `l`已经指向了存在的结点(为了**更自然地适配**构造函数已经确定的行为，即**初始化**时就让head指向了存在的结点)

而这里我们二叉树的构造函数中 `root`初始就是个`nullptr`，因此要改的话必须要改 `root; root->left; root->right`**本身**，在函数体内部创建新结点并修改`r`的值。
> 不知道为啥这勾吧课件老喜欢玩这种C语言游戏，莫名其妙的炫技
>
> 而且它创建广义表的函数实现根本跑不通，看了它的代码还干扰了👴自己实现

* 基于栈的二叉树非递归遍历

同样典中典的**递归法**前中后序遍历就不多说了，这里说一下基于栈的**非递归遍历**。呃其实就是如何把递归函数用栈**改写成非递归**。

说实话我是不太会这个的，手动模拟**函数调用堆栈模型**，直接抄的课件代码。直接看代码吧，实现在 `Tree/BinTree.h`的`xxxOrder_new()`系列函数。
> 话说改写成非递归感觉对性能啥的没啥本质上的提高，参数和调用现场该保存多少还是得保存多少，更重要的一点是，机器不会错，而你的模拟会错
>
> 权当复习函数模型了就是说🤭

* 二叉树的层次遍历

队列的应用了就是说，算法是非递归的，同样典中典。我只能说课件上的实现很丑，见 `levelOrder()`函数。

-----


## 线索二叉树

### 出现意图

用递归可以很方便实现前中后序遍历，生成一个**线性序列**。但是对于给定的一个结点，如何很方便得到其**前中后序遍历中**的**前驱结点**和**后续结点**？

显然这时候再去生成**整个**二叉树的遍历序列是不太划算的，并且如果二叉树中有结点值相等，单从序列的值来看是**难以区分**是哪个结点，**线索二叉树**就是为了解决这个问题。

对树做**预处理**，将某种遍历序列的**前驱后续关系**直接记录在树的**存储结构中**，以便于**高效找到**某结点的前驱和后续结点。
> 显然线索二叉树有三种，前序线索二叉树、中序线索二叉树和后续线索二叉树

### 实现线索树

* 实现方法的思考

一个最简单的想法，每个结点再增加两个指针域。即除了左右子树的指针，再加一个**前驱指针**和一个**后续指针**，这样一个结点就有4个指针域了。

但是，一个基本的事实是：原来的二叉链表实现中，n个结点的树，有**2n个指针域**，但是**只有n-1个指针**是被利用起来的(也就是树中的n-1条**边**)，剩下**n+1个指针都是空的**。

这个利用率已经非常低了，先别想着直接暴力增加新的指针域，能不能把这些以前没用上的指针域**利用起来**？

* 左右线索标志

我们的设计是，每个结点**增加两个比特**，即左右线索标志，利用标志信息来**充分利用**那些空的指针域，设计如下：
```cpp
template<class T>
struct node{
    T data;
    char ltag:1;
    char rtag:1;
    node *left;
    node *right;
};
```
当 `ltag/rtag == 0`时，左右指针和二叉链表一样表示子树；当 `ltag/rtag == 1`时，这时的左右指针就表示**前驱后继**了，也就是**线索**。
> 但是C语言这个**位域**分配结构体时，还得**考虑对齐**，**紧挨着写**在一起是最省的。设置成 `char`类型，这两个比特最小可以**只占一个字节**。
>
> 只浪费了6个比特，神中神就是说🤭

* 实现中序线索二叉树

课件上只重点给出了**中序线索树**的实现，这是因为，结点没有线索可用时，即`tag==0`左右指针表示子树时，某个结点中序遍历的的前驱和后继结点都比较容易寻找。

即：**前驱**结点为左子树中序遍历的**最后一个结点**；**后继**结点为右子树中序遍历的**第一个结点**。

对于二叉树的中序线索化也很巧妙，中序递归模板，同时利用了 `pre`指针引用神来之笔。具体实现见 `Tree/ThreadTree.h`文件中。
> 太麻烦了这东西，真不想看了😭而且感觉日常也用不到

* 中序线索树的应用

利用中序线索找出**任意给定结点的父结点**，之前二叉链表的实现中，我们**用递归**的方法，复杂度为 `O(n^2)`。用中序线索的话可以降到**线性级别**。

这里不得不提一下中序线索树的**优越性**，左中右的特点，实际上中序遍历下的**最后一个**结点就是不断`r = r->right`的**最右侧**结点。而中序遍历下**第一个结点**就是 `r = r->left`**最左侧**结点。
> 我们实现找中序遍历下的第一个结点`InFirst`和最后一个结点 `InLast`，实际上是**尾递归**，和**迭代**一回事！两种写法行为完全一致。

**基本思路**：任意结点只可能是**直接父**的左指针或者右指针**两种情况**。

因此对于任意给出的结点 `r`，**首先假设**它是其**直接父**结点的左指针，这样的话其父结点**就是**：`r`的右子树中序遍历的**最后一个结点**的**后驱**线索。
> 由于树已经被中序线索化了，除了首个结点的前驱和末尾结点的后续，已经**没有空指针**了，因此不能靠 `r->right==nullptr`来判断是否到达最右侧，而要看是否`rtag == 1`，碰到线索说明到头了
>
> 这也是在 `CreateInThread()`中序线索函数时，千万不能忘了让最后一个结点 `pre`也要标记好 `rtag==1`，即使其后驱线索为 `nullptr`。

如果这个后驱**为空**则说明找到整个树的末尾结点了，`r`**实际上**是直接父的**右指针**，那么根据左中右的特点，其父结点是其**左子树**中序下**第一个结点的前驱**。

而如果这个后驱**非空**还需要判断到底是不是**直接父**结点，因为有可能是**爷爷结点**的左子树下而在直接父的右子树下，这时的`p`**是爷爷不是直接父**。

总之只要 `p && p->left!=r`就说明**假设错误了**，`r`应该是**直接父**的右指针。（返回爷结点的情况很容易忽略就是说😄

> 当然可以先假设为父结点的右指针，这样若左子树首个结点前驱为空说明实际为左指针，一回事的。总之因为我们不知道到底是左子还是右子，只能**都尝试一遍**。

具体实现在 `Parent()`函数中，就是两个平行的`while`循环，复杂度为`O(n)`，并且如果试图找根结点的父结点，会返回`nullptr`，很和谐就是说😄

-----


## 树和森林

上面讲的都是**二叉树**，每个结点最多有两个子树，那么如何表示广义的树形结构？

### 树的表示

#### 一些尝试
* 广义表表示法

显然广义表可以满足这个需求，最强大的链式结构，每个**子树对应一个子表**，并且由于树的定义，左右子树**没有交集**，因此也**不存在共享表**的问题。

<img alt="picture/img_3.png" height="222" src="../picture/img_3.png" width="408"/>

> 广义表很强大，但是从图中可以看到，广义表的天然语义是一种**包含关系**，而树形结构是**父子关系**，表示起来还是**不够自然**。

* 双亲表示法

用数组来存储结点，其实就是个非常简单的**静态链表**，数组中的每个元素存的**结点值**和**父结点的下标**，而**存放顺序**一般不做特殊要求，按照层次序就可以。
> 比二叉树那节提到的静态二叉链表简单的多，那个静态链表每个元素要存结点值、左右子结点**下标**以及父结点**下标**。这个双亲表示法，就还真**只存了**父结点下标🤭xs

* 子女链表表示法

同样是用数组来存储结点，但是双亲表示法的话，由于每个结点**只有一个确定的父结点**，因此可以实现固定好数组元素大小。

而子女链表表示中，每个结点不再存父结点的下标，而是存**所有子女结点的数组下标**，因为子女个数是不确定的，因此用**链表结构**来存储。
> 同样数组中结点的存储顺序随意，如果是**有序树**，子女结点下标在链表中应该**从左到右**存储。

* 子女指针表示

上面两种数组结构看看笑话就好了，正常人应该都不会用这东西吧🤭子女指针类似于二叉链表那样每个结点存放子女结点指针，但问题在于，每个结点的**子女个数是不确定**的，因此只能让结点包含**该树的度**个指针。

**度**就是最大的结点出边树，显然这样会造成**很多指针域的浪费**。

#### 子女兄弟表示法

可以看到上面几种缺点都太明显，能不能像二叉链表那样，**两个指针**走天下？这就是**子女兄弟**表示法，每个结点的结构如下：

```cpp
template<class T>
struct node{
    T data;
    node<T>* son; //指向下一层
    node<T>* bro; //指向同一层的后续
};
```
子女指针表示法中，每个指针**都**表示的父子关系，因此难以处理子女数不确定的情况；而子女兄弟表示法中，一个指针表示**父子关系**、一个指针表示**兄弟关系**，多个子女可以靠兄弟指针连续在一起。

形成的结构如下：

<img alt="picture/img_4.png" height="250" src="../picture/img_4.png" width="370"/>

这样一来**层次结构**非常清楚，并且完美表示了**任意树**，可以说综合了**子女链表**和**子女指针**两种表示法。

可以看到对于所有子女的访问都是靠**第一个孩子**，因此也叫**长子-兄弟表示法**


### 子女兄弟表示实现

具体实现在`Tree.h`文件中。

典中典的做法， `Tree`类中包含了一个`TreeNode *root`指针，表示**树的根**。初始化为`nullptr`表示树为空.

在子女兄弟树上的递归算法也是典中典，无非就是在二叉树中，只有左右**两个子女**，而广义树中有很**多个子女**罢了，**递归的思路是完全一样**的😄

`Tree`类还有一个成员变量`TreeNode *current`**当前结点指针**，这玩意说实话感觉没啥用处，课本上的解释说是为了在**子女链表**中有序**插入新的结点**时可以用`current`**指示位置**来提高插入效率。
> 然而课本课件彷佛完全忘了插入算法这一回事，写了接口没写实现😅那我也不写了嘻嘻🤭

### 表示森林

就是说我们太喜欢**二叉结构**了，长子-兄弟表示法就是二叉结构，而且可以很好表示**任意树**，注意到对于**单独一棵树**，长子-兄弟表示法下，根结点一定**没有兄弟只有子女**。

这太好力，表示森林的话就可以让这些**树的根互相成为兄弟**了，同样还是长子-兄弟的**二叉结构**，比如：

<img alt="picture/img_5.png" height="290" src="../picture/img_5.png" width="370"/>

显然，**森林和二叉树有一一对应的关系**。

#### 森林的遍历

* 森林的先根遍历

**等同于二叉树的先序遍历**

可以使用之前单棵树的遍历算法，**一棵树一棵树**进行，每棵树上**外部调用**递归算法，不难看出是**中左右**的顺序

* 森林的后根遍历

**等同于二叉树的中序遍历**

同样也要一棵树一棵树进行，每棵树上**外部调用**递归算法，不难看出是**左中右**的顺序

* 森林的层次遍历

区别只在于，初始化队列时，需要把根的**所有兄弟**都入队，也就是森林每棵树的根，因为在**同一层**嘛🤭，而原来第一层只有一个根，后续的队列操作和之前完全一致。


## 堆

## 霍夫曼树

