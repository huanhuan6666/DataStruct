## 栈
线性表，不管是顺序存储还是链式存储，我们说的是ADT的线性表，是栈和队列的基础。

栈和队列，是**限制存取位置**的表结构。

很容易理解，比如STL的vector明明就能实现栈的功能，但是还有stack这种wrapper套皮vector的栈，就是因为ADT stack的Function是不提供按照下标访问功能的。

### 顺序栈
我们实现的最基础的基于数组的**顺序栈**模板类定义在`Stack/Stack.h`文件中。

我们约定：
* `top == -1`时栈为空
* `top`表示栈顶元素的下标

### 双栈共享栈空间
这是个比较秀的结构，说是为了更好地利用内存空间，减少内存的浪费。定义在`Stack/DualStack.h`文件中。

让两个栈共享一个数组，一个从0到maxSize生长，另一个从maxSize到0生长，有点像内存模型的栈和堆**双向奔赴**就是说😄

使用时需要指定用哪个栈，于是约定：
* 栈顶碰到一起则栈满了
* `top == 0`或者`top == maxSzie`为空，取决于用哪个栈，是从高到底生长还是从低到高生长。

不会真有人用这种东西吧，有点古早就是说，也可能是现在的封装库已经足够强大了。

### 链式栈

上面那种双栈共享空间来节省空间实在有点辣眼睛，还是链式存储吧。定义在`Stack/LinkedStack.h`文件中。

* 没有附加头节点，也就是说`top == nullptr`栈为空

* `push`和`pop`都直接用最简单的头插法，并且显然，链式栈不可能满。

### 栈的应用
典中典的计算中缀表达式，我们不必把中缀表达式转换成后缀，然后再解析后缀表达式那么麻烦，而是直接用双栈法。

* 设置一个val栈，一个opt栈，每读到一个数字就压如val栈，读到opt的话：
    * 设置opt的优先级，( 最低=0，+-=1， */=2，)最高=3
    * 如果当前的opt的优先级比opt.top()的优先级**高或等于**，那么就pop出opt的top并且val的两个值计算后再次push入val栈中
        * 直到当前的opt的优先级**大于**opt的top，或者栈为空或者遇到(才停止pop，将当前操作符压入opt中
        * 如果当前opt为)那么遇到(的话，也需要将(弹出，也就是说一对括号已经完成它的使命了🤭
        * 这样保证了高优先级的运算符先执行，同等优先级的运算符按从左到右的顺序执行
* 首先在opt栈push进(并在exp后加上`)`作为**哨兵**，保证最后压入)后可以保证将栈opt清理干净

简单计算器的实现在文件`SimpleCalculator.cpp`中，利用的是上面实现的链式栈，只能实现**一位整数**的加减乘除。

没有转换成后缀再去解析，是因为生成后缀表达式的过程和上面几乎完全一致，没有必要多此一举，如果确实需要后缀表达式的话：
* 不需要val栈，因为遇到数字直接输出，只需要opt栈，对于opt的操作和上面完全一致
* 当然可以设置()哨兵，即在opt栈先压一个(，在字符串最后拼一个)
> 因为后缀表达式不会出现括号。设置哨兵可以保证最后的)可以清空opt栈，更方便。

解析后缀表达式时，不用opt栈只用val栈，碰见数字直接压入val栈，碰见符号则弹出两个数字**计算后再压入**val栈，最后val栈的栈顶就是计算结果。

😄就是说生成后缀表达式只用opt栈，解析后缀表达式只用val栈，索性**直接双栈**痛快点。
